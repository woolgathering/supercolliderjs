# Synth
Package: <a href="#/packages/dryads/api">@supercollider/dryads</a>

<div class="entity-box"><div class="Class"><h3 class="class-header" id="Synth"><span class="token keyword">class</span> <span class="class">Synth</span></h3><span class="token keyword">extends</span> <span class="type reference">Dryad&lt;<span class="type reference">Properties</span>&gt;</span><p class="short-text">Creates a synth on the server.</p><p class="">Properties:
- def
- args
</p><div class="section-heading">Constructor</div><div class="class-member"></div><div class="section-heading">Property</div><div class="class-member"><h4 id="children"><span class="token property">children</span> <span class="type ">[object Object]</span>[]</h4></div><div class="class-member"><h4 id="properties"><span class="token property">properties</span> <span class="type reference">Properties</span></h4></div><div class="section-heading">Accessor</div><div class="class-member"><h4 id="isDryad"><span class="token property">isDryad</span> <span class="type token entity">boolean</span></h4><p class="short-text">This method is never actually called, but merely because its implemented
(dryad.isDryad is not undefined) it marks the things as being a Dryad.</p></div><div class="section-heading">Method</div><div class="class-member"></div><div class="class-member"><h4 id="add"><span class="token function">add</span>(): <span class="type reference">Command</span></h4></div><div class="class-member"></div><div class="class-member"></div><div class="class-member"></div><div class="class-member"></div><div class="class-member"><h4 id="prepareForAdd"><span class="token function">prepareForAdd</span>(): <span class="type reference">Command</span></h4></div><div class="class-member"><h4 id="remove"><span class="token function">remove</span>(): <span class="type reference">Command</span></h4></div><div class="class-member"><h4 id="requireParent"><span class="token function">requireParent</span>(): <span class="type token entity">string</span></h4><p class="short-text">If there is no SCServer in the parent context,
then this will wrap itself in an SCServer</p></div><div class="class-member"></div><div class="class-member"></div><div class="class-member"><h4 id="fromFile"><span class="token function">fromFile</span>(<span class="nowrap">path: <span class="type token entity">string</span></span>, <span class="nowrap">args: <span class="type reference">SynthParams</span> =  {}</span>): <span class="type reference">Synth</span></h4><p class="short-text">Make a Synth that will play the SynthDef compiled from an *.scd source code file</p></div><div class="class-member"><h4 id="fromSource"><span class="token function">fromSource</span>(<span class="nowrap">source: <span class="type token entity">string</span></span>, <span class="nowrap">args: <span class="type reference">SynthParams</span> =  {}</span>): <span class="type reference">Synth</span></h4><p class="short-text">Make a Synth that will play the SynthDef compiled from sclang source code.</p><p class="">source may be fully defined:
  `SynthDef("defName", { |out=0, freq=440| Out.ar(SinOsc.ar(freq)) });`
or more simply:
  `{|freq| SinOsc.ar(freq)}`
or even just:
   `|freq| SinOsc.ar(freq)`
</p></div><div class="class-member"></div></div></div>
